SolidityScan result for code-sample/src/Registry.sol:
#	NAME	SEVERITY	CONFIDENCE	DESCRIPTION	REMEDIATION
1.	INCORRECT ACCESS CONTROL	critical	1	
Access control plays an important role in the segregation of privileges in smart contracts and other applications. If this is misconfigured or not properly validated on sensitive functions, it may lead to loss of funds, tokens and in some cases compromise of the smart contract.

The contract is importing an access control library but the function is missing the modifier.

Not Available
2.	UNCHECKED ARRAY LENGTH	medium	2	
Ethereum is a very resource-constrained environment. Prices per computational step are orders of magnitude higher than with centralized providers. Moreover, Ethereum miners impose a limit on the total number of Gas consumed in a block. If array.length is large enough, the function exceeds the block gas limit, and transactions calling it will never be confirmed.

for (uint256 i = 0; i < array.length ; i++) { cosltyFunc(); }


This becomes a security issue if an external actor influences array.length.

E.g., if an array enumerates all registered addresses, an adversary can register many addresses, causing the problem described above.

Not Available
3.	OUTDATED COMPILER VERSION	low	2	
Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.

Not Available
4.	MISSING EVENTS	low	1	
Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transaction’s log — a special data structure in the blockchain.
These logs are associated with the address of the contract which can then be used by developers and auditors to keep track of the transactions.
The contract was found to be missing these events on the function which would make it difficult or impossible to track these transactions off-chain.

Not Available
5.	USE OWNABLE2STEP	low	0	
Ownable2Step is safer than Ownable for smart contracts because the owner cannot accidentally transfer the ownership to a mistyped address. Rather than directly transferring to the new owner, the transfer only completes when the new owner accepts ownership.

Not Available
6.	MISSING ZERO ADDRESS VALIDATION	low	2	
The contract is found to lack proper validation for zero address inputs in critical functions, particularly where an 'address' input is expected, like during initialization or setting ownership. Failure to validate zero addresses can result in unwanted contract states, such as having critical roles or operations reference the zero address (0x0), which is universally considered an invalid and non-operational address within Ethereum, potentially leading to the loss of assets or control over the contract's functionality.

Not Available
7.	MISSING INDEXED KEYWORDS IN EVENTS	informational	2	
Events are essential for tracking off-chain data and when the event paraemters are indexed they can be used as filter options which will help getting only the specific data instead of all the logs.

Not Available
8.	BLOCK VALUES AS A PROXY FOR TIME	informational	1	
Contracts often need access to time values to perform certain types of functionality. Values such as block.timestamp and block.number can be used to determine the current time or the time delta. However, they are not recommended for most use cases.


For block.number, as Ethereum block times are generally around 14 seconds, the delta between blocks can be predicted. The block times, on the other hand, do not remain constant and are subject to change for a number of reasons, e.g., fork reorganizations and the difficulty bomb.


Due to variable block times, block.number should not be relied on for precise calculations of time.

Not Available
9.	CONSTRUCTORS SHOULD EMIT AN EVENT	informational	1	
A constructor in a smart contract executes only once during deployment, making it crucial to log this action for transparency. Without an emitted event, tracking contract deployment becomes difficult, reducing the ability to audit and monitor contract instances.

Not Available
10.	REQUIRE INSTEAD OF REVERT	informational	1	
The require Solidity function guarantees the validity of the condition(s) passed as a parameter that cannot be detected before execution. It checks inputs, contract state variables, and return values from calls to external contracts.


Using require instead of revert improves the overall readability of the contract code.


The construction if (condition) { revert(); } is equivalent to require(!condition);

Not Available
11.	ADDING A RETURN STATEMENT WHEN THE FUNCTION DEFINES A NAMED RETURN VARIABLE IS REDUNDANT	informational	2	
The contract defines a named return despite having a return statement. This causes redundancy and can lead to potential confusion in the code.

Not Available
12.	REVERT STATEMENTS WITHIN EXTERNAL AND PUBLIC FUNCTIONS CAN BE USED TO PERFORM DOS ATTACKS	informational	0	
In public and external functions, improper use of revert can be exploited for Denial of Service (DoS) attacks. An attacker can intentionally trigger these 'revert' conditions, causing legitimate transactions to consistently fail. For example, if a function relies on specific conditions from user input or contract state, an attacker could manipulate these to continually force reverts, blocking the function's execution.

Not Available
13.	ABI ENCODE IS LESS EFFICIENT THAN ABI ENCODEPACKED	gas	0	
The contract is using abi.encode() in the function. In abi.encode(), all elementary types are padded to 32 bytes and dynamic arrays include their length, whereas abi.encodePacked() will only use the minimal required memory to encode the data.

Lines: ["418:418","434:434"]	
Unless explicitly needed , it is recommended to use abi.encodePacked() instead of abi.encode().

14.	STORING STORAGE VARIABLES IN MEMORY	gas	0	
Whenever a struct, array, or a mapping is stored and copied to a memory variable, each member is read from the storage and then copied. This becomes expensive. This could easily be optimized by using the storage keyword which just stores a pointer to the storage instead, making the whole process a lot cheaper.

Lines: ["477:477"]	
It is recommended to use storage instead of memory in this particular case to optimize gas.

15.	CHEAPER INEQUALITIES IN IF()	gas	1	
The contract was found to be doing comparisons using inequalities inside the if statement.
When inside the if statements, non-strict inequalities (>=, <=) are usually cheaper than the strict equalities (>, <).

Lines: ["61:61","202:202","473:473"]	
It is recommended to go through the code logic, and, if possible, modify the strict inequalities with the non-strict ones to save ~3 gas as long as the logic of the code is not affected.

16.	AVOID RE-STORING VALUES	gas	0	
The function is found to be allowing re-storing the value in the contract's state variable even when the old value is equal to the new value. This practice results in unnecessary gas consumption due to the Gsreset operation (2900 gas), which could be avoided. If the old value and the new value are the same, not updating the storage would avoid this cost and could instead incur a Gcoldsload (2100 gas) or a Gwarmaccess (100 gas), potentially saving gas.

Lines: ["52:55","60:71","103:109","176:183"]	
To optimize gas usage, add a check to compare the old value with the new value before updating the storage. Only perform the storage update if the new value is different from the old value. This approach will prevent unnecessary storage writes and reduce gas consumption.

17.	GAS OPTIMIZATION IN INCREMENTS	gas	0	
++i costs less gas compared to i++ or i += 1 for unsigned integers. In i++, the compiler has to create a temporary variable to store the initial value. This is not the case with ++i in which the value is directly incremented and returned, thus, making it a cheaper alternative.

Lines: ["445:445"]	
Consider changing the post-increments (i++) to pre-increments (++i) as long as the value is not used in any calculations or inside returns. Make sure that the logic of the code is not changed.

18.	OPTIMIZING ADDRESS ID MAPPING	gas	0	
Combining multiple address/ID mappings into a single mapping using a struct enhances storage efficiency, simplifies code, and reduces gas costs, resulting in a more streamlined and cost-effective smart contract design.

It saves storage slot for the mapping and depending on the circumstances and sizes of types, it can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they fit in the same storage slot.

Lines: ["47:47","243:243","297:297"]	
It is suggested to modify the code so that multiple mappings using the address->id parameter are combined into a struct.

19.	ARRAY LENGTH CACHING	gas	2	
During each iteration of the loop, reading the length of the array uses more gas than is necessary. In the most favorable scenario, in which the length is read from a memory variable, storing the array length in the stack can save about 3 gas per iteration. In the least favorable scenario, in which external calls are made during each iteration, the amount of gas wasted can be significant.

Lines: ["249:249","256:256","445:447"]	
Consider storing the array length of the variable before the loop and use the stored length instead of fetching it in each iteration.

20.	UNNECESSARY CHECKED ARITHMETIC IN LOOP	gas	0	
Increments inside a loop could never overflow due to the fact that the transaction will run out of gas before the variable reaches its limits. Therefore, it makes no sense to have checked arithmetic in such a place.

Lines: ["249:249","256:256","445:445"]	
It is recommended to have the increment value inside the unchecked block to save some gas.

21.	PUBLIC CONSTANTS CAN BE PRIVATE	gas	2	
Public constant variables cost more gas because the EVM automatically creates getter functions for them and adds entries to the method ID table. The values can be read from the source code instead.

Lines: ["161:161","384:384"]	
If reading the values for the constants are not necessary, consider changing the public visibility to private.

22.	REVERTING FUNCTIONS CAN BE PAYABLE	gas	0	
If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.

Lines: ["52:55","99:101","248:250","255:257","308:314","320:327","415:452","459:462"]	
In the above code, the onlyOwner modifier ensures that only the contract owner can execute the ${function_name}. If a normal user attempts to call this function, the transaction will automatically revert. By marking the ${function_name} as payable, we can optimize gas costs for legitimate callers since the compiler will skip the checks for payment.

23.	CHEAPER CONDITIONAL OPERATORS	gas	0	
During compilation, x != 0 is cheaper than x > 0 for unsigned integers in solidity inside conditional statements.

Lines: ["61:61"]	
Consider using x != 0 in place of x > 0 in uint wherever possible.

24.	UNUSED IMPORTS	gas	2	
Solidity is a Gas-constrained language. Having unused code or import statements incurs extra gas usage when deploying the contract.

Lines: ["5:5"]	
It is recommended to remove the import statement if it’s not supposed to be used.

25.	DEFINE CONSTRUCTOR AS PAYABLE	gas	0	
Developers can save around 10 opcodes and some gas if the constructors are defined as payable.

However, it should be noted that it comes with risks because payable constructors can accept ETH during deployment.

Lines: ["80:84"]	
It is suggested to mark the constructors as payable to save some gas. Make sure it does not lead to any adverse effects in case an upgrade pattern is involved.

26.	FUNCTIONS CAN BE IN-LINED	gas	0	
The internal function was called only once throughout the contract. Internal functions cost more gas due to additional JUMP instructions and stack operations.

Lines: ["213:216","262:266","271:275"]	
Creating a function for a single call is not necessary if it can be in-lined. It is recommended to implement the logic using in-line codes to save gas.

27.	AVOID ZERO-TO-ONE STORAGE WRITES	gas	2	
Writing a storage variable from zero to a non-zero value costs 22,100 gas (20,000 for the write and 2,100 for cold access), making it one of the most expensive operations. This is why patterns like OpenZeppelin’s ReentrancyGuard use 1 and 2 instead of 0 and 1—to avoid the high cost of zero-to-non-zero writes. Non-zero to non-zero updates cost only 5,000 gas.

Lines: ["182:182","193:193","207:207","449:449"]	
To mitigate this gas inefficiency, consider initializing storage variables to non-zero values during contract deployment if possible. Alternatively, design contract logic to minimize the number of times storage variables are set from zero to non-zero values. This can be achieved by setting default non-zero values where applicable or by batching storage updates to reduce the frequency of costly initializations.

28.	DEFAULT INT VALUES ARE MANUALLY RESET	gas	0	
The contract is found to inefficiently reset integer variables to their default value of zero using manual assignment. In Solidity, manually setting a variable to its default value does not free up storage space, leading to unnecessary gas consumption. Instead, using the .delete keyword can achieve the same result while also freeing up storage space on the Ethereum blockchain, resulting in gas cost savings.

Lines: ["193:193","207:207","273:273","323:323","461:461"]	
To optimize gas usage, replace manual resets of integer variables with the .delete keyword. This not only sets the variable to its default value but also frees up storage space, leading to reduced gas costs.

29.	CUSTOM ERRORS TO SAVE GAS	gas	2	
The contract was found to be using revert() statements. Since Solidity v0.8.4, custom errors have been introduced which are a better alternative to the revert.
This allows the developers to pass custom errors with dynamic data while reverting the transaction and also making the whole implementation a bit cheaper than using revert.

Lines: ["460:460"]	
It is recommended to replace all the instances of revert() statements with error() to save gas.

30.	ASSIGNING TO STRUCTS CAN BE MORE EFFICIENT	gas	0	
The contract is found to contain a struct with multiple variables defined in it. When a struct is assigned in a single operation, Solidity may perform costly storage operations, which can be inefficient. This often results in increased gas costs due to multiple SLOAD and SSTORE operations happening at once

Lines: ["430:435"]	
Instead of assigning all struct elements at once, initialize the struct as empty and assign each element individually. This can help in reducing gas costs by minimizing potentially expensive storage operations in a single transaction.

Scan Summary:

  Lines Analyzed: 402

  Scan Score: 89.81

  Issue Distribution: { "critical": 0, "gas": 45, "high": 0, "informational": 27, "low": 19, "medium": 2 }

For more details, go to SolidityScan.